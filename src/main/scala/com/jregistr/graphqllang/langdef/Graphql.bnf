{
    parserClass="com.jregistr.graphqllang.parser.GraphQlParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="GraphQl"
    psiImplClassSuffix="Impl"
    psiPackage="com.jregistr.graphqllang.psi"
    psiImplPackage="com.jregistr.graphqllang.psi.impl"

    elementTypeHolderClass="com.jregistr.graphqllang.psi.GraphQlTokenTypes"
    elementTypeClass="com.jregistr.graphqllang.langdef.GraphQlLangElementType"
    tokenTypeClass="com.jregistr.graphqllang.langdef.GraphQlLangTokenType"

    tokens = [
        TYPE='type'
        INPUT='input'
        ENUM='enum'
        SCALAR='scalar'
        SCHEMA='schema'
        UNION='union'
        INTERFACE='interface'
        IMPLEMENTS='implements'
        QUERY='query'
        FRAGMENT='fragment'
        DIRECTIVE='directive'
        QUERY='query'
        MUTATION='mutation'
        SUBSCRIPTION='subscription'
        EXTEND='extend'

        LEFT_PAREN='('
        RIGHT_PAREN=')'

        LEFT_CURLY='{'
        RIGHT_CURLY='}'

        LEFT_BRACKET='['
        RIGHT_BRACKET=']'

        COLON=':'
        COMMA=','
        EQUALS='='
        PIPE='|'
        REQUIRED='!'
        DIRECTIVE_IDENTIFIER='regexp:@([_A-Za-z][_0-9A-Za-z]*)'
        VARIABLE_IDENTIFIER='regexp:\$([_A-Za-z][_0-9A-Za-z]*)'
        FRAGMENT_DOTS='...'
        FRAGMENT_ON='on'

        IDENTIFIER="regexp:[_A-Za-z][_0-9A-Za-z]*"
        STRING_LITERAL='regexp:".*"'
        NUMBER_LITERAL='regexp:-?[0-9]+(\.[0-9]+)?'

        WHITE_SPACE = 'regexp:\s+'
        SINGLE_LINE_COMMENT="regexp:#.*"
    ]
}

// addtl -> additional
// decl -> declaration
// def -> definition
// impl -> implemented(ation)
// sel -> selection
// cond -> condition
// loc -> location

GraphQlDocument ::= Definition*

Definition ::=

ObjectTypeDef
|
InterfaceTypeDef
|
EnumTypeDef
|
UnionTypeDef
|
ScalarTypeDef
|
RootSchemaTypeDef
|
InputObjectTypeDef
|
DirectiveDef
|
ExtendTypeDef
|
ExecutableDef



NamedTypeDef ::= IDENTIFIER
NameOfSomeType ::= IDENTIFIER
NameOfSomeField ::= IDENTIFIER
DirectiveLocation ::= IDENTIFIER

BOOLEAN_LITERAL ::= 'true' | 'false'
Literal ::= NUMBER_LITERAL | STRING_LITERAL | BOOLEAN_LITERAL
VariableReference ::= VARIABLE_IDENTIFIER
StaticValue ::= IDENTIFIER

SimpleFieldValueDecl ::= Literal | SimpleObjectValueDecl | SimpleArrayValuesDecl | StaticValue

SimpleObjectValueDecl ::= LEFT_CURLY SimpleObjectValueFieldDecl SimpleObjectValueAddtlFieldDecl* RIGHT_CURLY
SimpleObjectValueFieldDecl ::= NameOfSomeField COLON SimpleFieldValueDecl
SimpleObjectValueAddtlFieldDecl ::= COMMA? SimpleObjectValueFieldDecl

SimpleArrayValuesDecl ::= LEFT_BRACKET SimpleArrayInnerValDecl SimpleArrayInnerValAddtlDecl* RIGHT_BRACKET
SimpleArrayInnerValDecl ::= SimpleFieldValueDecl
SimpleArrayInnerValAddtlDecl ::= COMMA? SimpleArrayInnerValDecl

///------------
CompositeFieldValueDecl ::= Literal | CompositeObjectValueDecl | CompositeArrayValuesDecl | VariableReference | StaticValue

CompositeArrayValuesDecl ::= LEFT_BRACKET CompositeArrayInnerValDecl CompositeArrayInnerValAddtlDecl* RIGHT_BRACKET
CompositeArrayInnerValDecl ::= CompositeFieldValueDecl
CompositeArrayInnerValAddtlDecl ::= COMMA? CompositeArrayInnerValDecl

CompositeObjectValueDecl ::= LEFT_CURLY CompositeObjectValueFieldDecl CompositeObjectValueFieldAddtlDecl* RIGHT_CURLY
CompositeObjectValueFieldDecl ::= NameOfSomeField COLON CompositeFieldValueDecl
CompositeObjectValueFieldAddtlDecl ::= COMMA? CompositeObjectValueFieldDecl

TypeDecl ::= BasicTypeDecl | ListTypeDecl
BasicTypeDecl ::= NameOfSomeType REQUIRED?
ListTypeDecl ::= LEFT_BRACKET BasicTypeDecl RIGHT_BRACKET REQUIRED?

//Distinction to Note and remember
//Argument definition is defining the arguments a field takes. I.E. foo(a: A, b: B): Bar
//Argument declaration stating the named arguments being passed. I.E. foo(a: "Cool", b: "cooler") {...}
SchemaArgumentsDeclSet ::= LEFT_PAREN SchemaArgumentDecl SchemaArgumentAddtlDecl* RIGHT_PAREN
SchemaArgumentDecl ::= NameOfSomeField COLON SimpleFieldValueDecl
SchemaArgumentAddtlDecl ::= COMMA? SchemaArgumentDecl

OperationArgumentDeclSet ::= LEFT_PAREN OperationArgumentDecl OperationArgumentAddtlDecl* RIGHT_PAREN
OperationArgumentDecl ::= NameOfSomeField COLON CompositeFieldValueDecl
OperationArgumentAddtlDecl ::= COMMA? OperationArgumentDecl


ArgumentsDefSet ::= LEFT_PAREN ArgumentDef ArgumentAddtlDef* RIGHT_PAREN
ArgumentDef ::= IDENTIFIER COLON TypeDecl
ArgumentAddtlDef ::= COMMA ArgumentDef

MemberFieldsSetDef ::= LEFT_CURLY MemberFieldDef MemberFieldAddtlDef* RIGHT_CURLY
MemberFieldDef ::= IDENTIFIER ArgumentsDefSet? COLON TypeDecl SchemaDirectivesDeclSet?
MemberFieldAddtlDef ::= COMMA? MemberFieldDef

SimpleMemberFieldsSetDef ::= LEFT_CURLY SimpleMemberFieldDef+ RIGHT_CURLY
SimpleMemberFieldDef ::= IDENTIFIER COLON TypeDecl

// Directive declaration is using directive such as on a field or object. I.E. field {a@foo}
// Directive definition is defining some directive. i.e. directive @foo on Field
SchemaDirectivesDeclSet ::= SchemaDirectiveDecl*
SchemaDirectiveDecl ::= DIRECTIVE_IDENTIFIER SchemaArgumentsDeclSet?

OperationDirectivesDeclSet ::= OperationDirectiveDecl*
OperationDirectiveDecl ::= DIRECTIVE_IDENTIFIER OperationArgumentDeclSet?

DirectiveDef ::= DIRECTIVE DIRECTIVE_IDENTIFIER ArgumentsDefSet? DirectiveDefLocCondSet
DirectiveDefLocCondSet ::= 'on' DirectiveLocation DirectiveDefLocAddtlCond*
DirectiveDefLocAddtlCond ::= PIPE DirectiveLocation

ObjectTypeDef ::= TYPE NamedTypeDef ObjectTypeImplInterfacesDef? SchemaDirectivesDeclSet? MemberFieldsSetDef
ObjectTypeImplInterfacesDef ::= IMPLEMENTS NameOfSomeType ObjectTypeInterfaceAddtlMember*
ObjectTypeInterfaceAddtlMember ::= COMMA NameOfSomeType

InterfaceTypeDef ::= INTERFACE NamedTypeDef MemberFieldsSetDef

EnumTypeDef ::= ENUM NamedTypeDef EnumValuesSetDef
EnumValuesSetDef ::= LEFT_CURLY EnumValueDef EnumAddtlValueDef* RIGHT_CURLY
EnumValueDef ::= IDENTIFIER
EnumAddtlValueDef ::= COMMA? IDENTIFIER

UnionTypeDef ::= UNION NamedTypeDef EQUALS UnionMemberDecl UnionAddtlMemberDecl*
UnionMemberDecl ::= NameOfSomeType
UnionAddtlMemberDecl ::= PIPE UnionMemberDecl

ScalarTypeDef ::= SCALAR NamedTypeDef

RootSchemaTypeDef ::= SCHEMA SimpleMemberFieldsSetDef

InputObjectTypeDef ::= INPUT NamedTypeDef SimpleMemberFieldsSetDef

ExtendTypeDef ::= EXTEND TYPE NameOfSomeType MemberFieldsSetDef

ExecutableDef ::=

OperationDef
|
FragmentDef

OperationDef ::= MaybeFullOperationDef? LEFT_CURLY SelectionSetDecl RIGHT_CURLY
MaybeFullOperationDef ::= OperationTypeDecl IDENTIFIER? OperationVariablesSetDef? OperationDirectivesDeclSet?
OperationTypeDecl ::= QUERY | MUTATION | SUBSCRIPTION

OperationVariablesSetDef ::= LEFT_PAREN OperationVariableDef OperationAddtlVariableDef* RIGHT_PAREN
OperationVariableDef ::= VARIABLE_IDENTIFIER COLON TypeDecl OperationVariableDefaultVal?
OperationVariableDefaultVal ::= EQUALS SimpleFieldValueDecl
OperationAddtlVariableDef ::= COMMA? OperationVariableDef

SelectionSetDecl ::= Selection AddtlSelection*
Selection ::=
FieldSelection
|
FragmentSpread
|
InlineFragment

AddtlSelection ::= COMMA? Selection

FieldSelection ::= FieldAlias? NameOfSomeField OperationArgumentDeclSet? OperationDirectivesDeclSet? FieldExpansionDecl?
FieldAlias ::= IDENTIFIER COLON
FieldExpansionDecl ::= LEFT_CURLY SelectionSetDecl RIGHT_CURLY

FragmentSpread ::= FRAGMENT_DOTS IDENTIFIER OperationDirectivesDeclSet?

InlineFragment ::= FRAGMENT_DOTS FragmentTypeCondition OperationDirectivesDeclSet? FieldExpansionDecl

FragmentTypeCondition ::= FRAGMENT_ON NameOfSomeType

FragmentDef ::= FRAGMENT IDENTIFIER FragmentTypeCondition OperationDirectivesDeclSet? LEFT_CURLY SelectionSetDecl RIGHT_CURLY