{
    parserClass="com.jregistr.graphqllang.parser.GraphQlParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="GraphQl"
    psiImplClassSuffix="Impl"
    psiPackage="com.jregistr.graphqllang.psi"
    psiImplPackage="com.jregistr.graphqllang.psi.impl"

    elementTypeHolderClass="com.jregistr.graphqllang.psi.GraphQlTokenTypes"
    elementTypeClass="com.jregistr.graphqllang.langdef.GraphQlLangElementType"
    tokenTypeClass="com.jregistr.graphqllang.langdef.GraphQlLangTokenType"

    tokens = [
        NOT_IMPL='NOT_YET_IMPL'
        TYPE='type'
        INPUT='input'
        ENUM='enum'
        SCALAR='scalar'
        SCHEMA='schema'
        UNION='union'
        INTERFACE='interface'
        IMPLEMENTS='implements'
        QUERY='query'
        FRAGMENT='fragment'
        DIRECTIVE='directive'
        QUERY='query'
        MUTATION='mutation'
        SUBSCRIPTION='subscription'
        EXTEND='extend'

        LEFT_PAREN='('
        RIGHT_PAREN=')'

        LEFT_CURLY='{'
        RIGHT_CURLY='}'

        LEFT_BRACKET='['
        RIGHT_BRACKET=']'

        COLON=':'
        COMMA=','
        EQUALS='='
        PIPE='|'
        REQUIRED='!'
        AMPERSAND='&'

        DIRECTIVE_IDENTIFIER='regexp:@(_?[A-Za-z][_0-9A-Za-z]*)'
        VARIABLE_IDENTIFIER='regexp:\$([_A-Za-z][_0-9A-Za-z]*)'
        FRAGMENT_DOTS='...'
        ON='on'

        IDENTIFIER="regexp:[_A-Za-z][_0-9A-Za-z]*"
        STRING_LITERAL='regexp:".*"'
        NUMBER_LITERAL='regexp:-?[0-9]+(\.[0-9]+)?'

        WHITE_SPACE = 'regexp:\s+'
        SINGLE_LINE_COMMENT="regexp:#.*"
    ]
}

// addtl -> additional
// decl -> declaration
// def -> definition
// impl -> implemented(ation)
// sel -> selection
// cond -> condition
// loc -> location

GraphQlDocument ::= Definition*

Definition ::=
TypeSystemDef
|
TypeSystemExtension
|
ExecutableDef

/* Begin common definition */

TypeName ::= IDENTIFIER
FieldName ::= IDENTIFIER
EnumValue ::= IDENTIFIER

Literal ::= NUMBER_LITERAL | STRING_LITERAL | BOOLEAN_LITERAL
BOOLEAN_LITERAL ::= 'true' | 'false'

// I.E. 10 or "foobar" or [1 2 3 4] or {a: 10 b: false}.
// Note:!!, CANNOT refer to variables via $foo
FieldValueDecl ::= Literal | ObjectValueDecl | ArrayValueDecl | EnumValue

// I.E. { a: "foobar" b: true }
ObjectValueDecl ::= LEFT_CURLY ObjectValueFieldDecl ObjectValueAddtlFieldDecl* RIGHT_CURLY
ObjectValueFieldDecl ::= FieldName COLON FieldValueDecl
ObjectValueAddtlFieldDecl ::= COMMA? ObjectValueFieldDecl

ArrayValueDecl ::= LEFT_BRACKET ArrayMemberDecl ArrayMemberAddtlDecl* RIGHT_BRACKET
ArrayMemberDecl ::= FieldValueDecl
ArrayMemberAddtlDecl ::= COMMA? ArrayMemberDecl

/* End common definition */


/* Begin Schema Definition Language */
TypeSystemDef ::=
RootSchemaTypeDef
|
TypeDefinition
|
DirectiveTypeDef


TypeDefinition ::=
ObjectTypeDef
|
InterfaceTypeDef
|
EnumTypeDef
|
UnionTypeDef
|
ScalarTypeDef
|
InputObjectTypeDef


TypeSystemExtension ::=
RootSchemaExtension
|
TypeExtension

TypeExtension ::=
ExtendObjectType
|
ExtendScalar
|
ExtendInterface
|
ExtendUnion
|
ExtendEnum
|
ExtendInputObject

NamedTypeDef ::= IDENTIFIER

// I.E. : Float or : Foobar
CompositeFieldTypeDecl ::= COLON FieldTypeDecl

// I.E. Float! or [[Float!]!]!
FieldTypeDecl ::= BasicTypeDecl | ListTypeDecl
BasicTypeDecl ::= TypeName REQUIRED?
ListTypeDecl ::= LEFT_BRACKET FieldTypeDecl RIGHT_BRACKET REQUIRED?

// I.E. (a: BB = 10, c:DD)
InputsDef ::= LEFT_PAREN InputValueSetDef RIGHT_PAREN

// I.E. foo: Bar = false baz: Foobar
InputValueSetDef ::= InputDef AddtlInputDef*
InputDef ::= FieldName CompositeFieldTypeDecl InputDefaultValueDef? SchemaDirectivesSetDecl?
AddtlInputDef ::= COMMA? InputDef
InputDefaultValueDef ::= EQUALS FieldValueDecl

// I.E. (a: 10 b: false c: "true")
SchemaArgumentsSetDecl ::= LEFT_PAREN SchemaArgumentDecl AddtlSchemaArgumentDecl* RIGHT_PAREN
SchemaArgumentDecl ::= FieldName COLON FieldValueDecl
AddtlSchemaArgumentDecl ::= COMMA? SchemaArgumentDecl

// I.E. @foo @bar(a: 10) @baz
SchemaDirectivesSetDecl ::= SchemaDirectiveDecl+
SchemaDirectiveDecl ::= DIRECTIVE_IDENTIFIER SchemaArgumentsSetDecl?

// I.E. {a: Int b: Float}
FieldsDefSet ::= LEFT_CURLY FieldDef AddtlFieldDef* RIGHT_CURLY
FieldDef ::= FieldName InputsDef? CompositeFieldTypeDecl SchemaDirectivesSetDecl?
AddtlFieldDef ::= COMMA? FieldDef

// I.E. schema {query: Query}
RootSchemaTypeDef ::= SCHEMA SchemaDirectivesSetDecl? RootSchemaOperationsSetDef
RootSchemaOperationsSetDef ::= LEFT_CURLY RootSchemaOperationTypeDef RootSchemaAddtlOperationTypeDef* RIGHT_CURLY
RootSchemaOperationTypeDef ::= FieldName COLON TypeName
RootSchemaAddtlOperationTypeDef ::= COMMA? RootSchemaOperationTypeDef

// I.E. type Dog implements Animal & Pet { bark(loudness: String = "Over 9000!" @foo @bar(a: 11)): Bark }
ObjectTypeDef ::= TYPE NamedTypeDef ImplInterfacesDeclSet? SchemaDirectivesSetDecl? FieldsDefSet?
ImplInterfacesDeclSet ::= IMPLEMENTS TypeName AddtlInterfacesSet?
AddtlInterfacesSet ::= AdditionalInterface+
AdditionalInterface ::= AMPERSAND TypeName

// I.E. interface Animal @foo {walk(distance: Int): Float}
InterfaceTypeDef ::= INTERFACE NamedTypeDef SchemaDirectivesSetDecl? FieldsDefSet?

// I.E. enum Direction { NORTH, SOUTH, EAST @value("west"), WEST @value("west") }
EnumTypeDef ::= ENUM NamedTypeDef SchemaDirectivesSetDecl? EnumValuesDefSet?
EnumValuesDefSet ::= LEFT_CURLY EnumValueDef EnumAddtlValueDef* RIGHT_CURLY
EnumValueDef ::= EnumValue SchemaDirectivesSetDecl?
EnumAddtlValueDef ::= COMMA? EnumValueDef

// I.E. union SupersonicVehicles = Jets | Rockets
UnionTypeDef ::= UNION NamedTypeDef SchemaDirectivesSetDecl? UnionMembersSetDef?
UnionMembersSetDef ::= EQUALS UnionMemberDef UnionAddtlMemberDef*
UnionMemberDef ::= TypeName
UnionAddtlMemberDef ::= PIPE? UnionMemberDef

// I.E. scalar DateTime @foo
ScalarTypeDef ::= SCALAR NamedTypeDef SchemaDirectivesSetDecl?

// I.E. input Point2D { x: Float @foo, y: Float }
InputObjectTypeDef ::= INPUT NamedTypeDef SchemaDirectivesSetDecl? InputObjectFieldsSetDef?
InputObjectFieldsSetDef ::= LEFT_CURLY InputValueSetDef RIGHT_CURLY

// I.E. directive @example on FIELD_DEFINITION | ARGUMENT_DEFINITION
DirectiveTypeDef ::= DIRECTIVE DIRECTIVE_IDENTIFIER InputsDef? DirectiveLocationsConditionDef
DirectiveLocationsConditionDef ::= ON DirectiveLocation DirectiveAddtlLocation*
DirectiveLocation ::= IDENTIFIER
DirectiveAddtlLocation ::= PIPE? DirectiveLocation

//  -------- Schema extensions --------


/* End Schema Definition Language*/

//----------------------------------------------------------------------------------------------------------------------

/* Begin Executable definitions*/
ExecutableDef ::=
OperationDef
|
FragmentDef

VariableReference ::= VARIABLE_IDENTIFIER














/*
NamedTypeDef ::= IDENTIFIER
NameOfSomeType ::= IDENTIFIER
NameOfSomeField ::= IDENTIFIER
DirectiveLocation ::= IDENTIFIER

BOOLEAN_LITERAL ::= 'true' | 'false'
Literal ::= NUMBER_LITERAL | STRING_LITERAL | BOOLEAN_LITERAL
VariableReference ::= VARIABLE_IDENTIFIER
StaticValue ::= IDENTIFIER

SimpleFieldValueDecl ::= Literal | SimpleObjectValueDecl | SimpleArrayValuesDecl | StaticValue

SimpleObjectValueDecl ::= LEFT_CURLY SimpleObjectValueFieldDecl SimpleObjectValueAddtlFieldDecl* RIGHT_CURLY
SimpleObjectValueFieldDecl ::= NameOfSomeField COLON SimpleFieldValueDecl
SimpleObjectValueAddtlFieldDecl ::= COMMA? SimpleObjectValueFieldDecl

SimpleArrayValuesDecl ::= LEFT_BRACKET SimpleArrayInnerValDecl SimpleArrayInnerValAddtlDecl* RIGHT_BRACKET
SimpleArrayInnerValDecl ::= SimpleFieldValueDecl
SimpleArrayInnerValAddtlDecl ::= COMMA? SimpleArrayInnerValDecl

///------------
CompositeFieldValueDecl ::= Literal | CompositeObjectValueDecl | CompositeArrayValuesDecl | VariableReference | StaticValue

CompositeArrayValuesDecl ::= LEFT_BRACKET CompositeArrayInnerValDecl CompositeArrayInnerValAddtlDecl* RIGHT_BRACKET
CompositeArrayInnerValDecl ::= CompositeFieldValueDecl
CompositeArrayInnerValAddtlDecl ::= COMMA? CompositeArrayInnerValDecl

CompositeObjectValueDecl ::= LEFT_CURLY CompositeObjectValueFieldDecl CompositeObjectValueFieldAddtlDecl* RIGHT_CURLY
CompositeObjectValueFieldDecl ::= NameOfSomeField COLON CompositeFieldValueDecl
CompositeObjectValueFieldAddtlDecl ::= COMMA? CompositeObjectValueFieldDecl

TypeDecl ::= BasicTypeDecl | ListTypeDecl
BasicTypeDecl ::= NameOfSomeType REQUIRED?
ListTypeDecl ::= LEFT_BRACKET BasicTypeDecl RIGHT_BRACKET REQUIRED?

//Distinction to Note and remember
//Argument definition is defining the arguments a field takes. I.E. foo(a: A, b: B): Bar
//Argument declaration stating the named arguments being passed. I.E. foo(a: "Cool", b: "cooler") {...}
SchemaArgumentsDeclSet ::= LEFT_PAREN SchemaArgumentDecl SchemaArgumentAddtlDecl* RIGHT_PAREN
SchemaArgumentDecl ::= NameOfSomeField COLON SimpleFieldValueDecl
SchemaArgumentAddtlDecl ::= COMMA? SchemaArgumentDecl

OperationArgumentDeclSet ::= LEFT_PAREN OperationArgumentDecl OperationArgumentAddtlDecl* RIGHT_PAREN
OperationArgumentDecl ::= NameOfSomeField COLON CompositeFieldValueDecl
OperationArgumentAddtlDecl ::= COMMA? OperationArgumentDecl


ArgumentsDefSet ::= LEFT_PAREN ArgumentDef ArgumentAddtlDef* RIGHT_PAREN
ArgumentDef ::= NamedTypeDef COLON TypeDecl DefaultValueDef? SchemaDirectivesDeclSet?
DefaultValueDef ::= EQUALS SimpleFieldValueDecl
ArgumentAddtlDef ::= COMMA ArgumentDef

FieldDefName ::= IDENTIFIER

MemberFieldsSetDef ::= LEFT_CURLY MemberFieldDef MemberFieldAddtlDef* RIGHT_CURLY
MemberFieldDef ::= FieldDefName ArgumentsDefSet? COLON TypeDecl SchemaDirectivesDeclSet?
MemberFieldAddtlDef ::= COMMA? MemberFieldDef

SimpleMemberFieldsSetDef ::= LEFT_CURLY SimpleMemberFieldDef SimpleAddtlMemberFieldDef* RIGHT_CURLY
SimpleMemberFieldDef ::= FieldDefName COLON TypeDecl
SimpleAddtlMemberFieldDef ::= COMMA? SimpleMemberFieldDef

// Directive declaration is using directive such as on a field or object. I.E. field {a@foo}
// Directive definition is defining some directive. i.e. directive @foo on Field
SchemaDirectivesDeclSet ::= SchemaDirectiveDecl*
SchemaDirectiveDecl ::= DIRECTIVE_IDENTIFIER SchemaArgumentsDeclSet?

OperationDirectivesDeclSet ::= OperationDirectiveDecl*
OperationDirectiveDecl ::= DIRECTIVE_IDENTIFIER OperationArgumentDeclSet?



TypeDef ::=
RootSchemaTypeDef
|
ObjectTypeDef
|
InterfaceTypeDef
|
EnumTypeDef
|
DirectiveDef
|
UnionTypeDef
|
ScalarTypeDef
|
ExtendScalarDef
|
InputObjectTypeDef
|
ExtendTypeDef

RootSchemaTypeDef ::= SCHEMA SchemaDirectivesDeclSet? RootSchemaOperationTypesDefSet
RootSchemaOperationTypesDefSet ::= LEFT_CURLY RootSchemaOperationTypeDef RootSchemaAddtlOperationTypeDef* RIGHT_CURLY
RootSchemaOperationTypeDef ::= IDENTIFIER COLON NameOfSomeType
RootSchemaAddtlOperationTypeDef ::= COMMA? RootSchemaOperationTypeDef

ObjectTypeDef ::= TYPE NamedTypeDef ObjectTypeImplInterfacesDef? SchemaDirectivesDeclSet? MemberFieldsSetDef
ObjectTypeImplInterfacesDef ::= IMPLEMENTS NameOfSomeType ObjectTypeInterfaceAddtlMember*
ObjectTypeInterfaceAddtlMember ::= COMMA NameOfSomeType

InterfaceTypeDef ::= INTERFACE NamedTypeDef MemberFieldsSetDef

EnumTypeDef ::= ENUM NamedTypeDef EnumValuesSetDef
EnumValuesSetDef ::= LEFT_CURLY EnumValueDef EnumAddtlValueDef* RIGHT_CURLY
EnumValueDef ::= IDENTIFIER
EnumAddtlValueDef ::= COMMA? IDENTIFIER

DirectiveDef ::= DIRECTIVE DIRECTIVE_IDENTIFIER ArgumentsDefSet? DirectiveDefLocCondSet
DirectiveDefLocCondSet ::= 'on' DirectiveLocation DirectiveDefLocAddtlCond*
DirectiveDefLocAddtlCond ::= PIPE DirectiveLocation

UnionTypeDef ::= UNION NamedTypeDef EQUALS UnionMemberDecl UnionAddtlMemberDecl*
UnionMemberDecl ::= NameOfSomeType
UnionAddtlMemberDecl ::= PIPE UnionMemberDecl

ScalarTypeDef ::= SCALAR NamedTypeDef SchemaDirectivesDeclSet?

ExtendScalarDef ::= EXTEND SCALAR NamedTypeDef SchemaDirectivesDeclSet?

InputObjectTypeDef ::= INPUT NamedTypeDef SimpleMemberFieldsSetDef

ExtendTypeDef ::= EXTEND TYPE NameOfSomeType MemberFieldsSetDef


ExecutableDef ::=
OperationDef
|
FragmentDef

OperationDef ::= MaybeFullOperationDef? LEFT_CURLY SelectionSetDecl RIGHT_CURLY
MaybeFullOperationDef ::= OperationTypeDecl IDENTIFIER? OperationVariablesSetDef? OperationDirectivesDeclSet?
OperationTypeDecl ::= QUERY | MUTATION | SUBSCRIPTION

OperationVariablesSetDef ::= LEFT_PAREN OperationVariableDef OperationAddtlVariableDef* RIGHT_PAREN
OperationVariableDef ::= VARIABLE_IDENTIFIER COLON TypeDecl DefaultValueDef?
OperationAddtlVariableDef ::= COMMA? OperationVariableDef

SelectionSetDecl ::= Selection AddtlSelection*

Selection ::=
FieldSelection
|
FragmentSpread
|
InlineFragment

AddtlSelection ::= COMMA? Selection

FieldSelection ::= FieldAlias? NameOfSomeField OperationArgumentDeclSet? OperationDirectivesDeclSet? FieldExpansionDecl?
FieldAlias ::= IDENTIFIER COLON
FieldExpansionDecl ::= LEFT_CURLY SelectionSetDecl RIGHT_CURLY

FragmentSpread ::= FRAGMENT_DOTS IDENTIFIER OperationDirectivesDeclSet?

InlineFragment ::= FRAGMENT_DOTS FragmentTypeCondition OperationDirectivesDeclSet? FieldExpansionDecl

FragmentTypeCondition ::= FRAGMENT_ON NameOfSomeType

FragmentDef ::= FRAGMENT IDENTIFIER FragmentTypeCondition OperationDirectivesDeclSet? LEFT_CURLY SelectionSetDecl RIGHT_CURLY
 */


/*
MaybeAddtlInterfaces?

MaybeAddtlInterfaces ::= AddtlInterfacesSetDecl | LegacyAddtlInterfacesSetDecl
AddtlInterfacesSetDecl ::= AddtlInterfaceDecl+
AddtlInterfaceDecl ::= AMPERSAND TypeName
LegacyAddtlInterfacesSetDecl ::= AddtlLegacyInterfaceDecl+
AddtlLegacyInterfaceDecl ::= COMMA TypeName
*/