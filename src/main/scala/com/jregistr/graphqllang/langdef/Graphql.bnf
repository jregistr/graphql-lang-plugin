{
    parserClass="com.jregistr.graphqllang.parser.GraphQlParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="GraphQl"
    psiImplClassSuffix="Impl"
    psiPackage="com.jregistr.graphqllang.psi"
    psiImplPackage="com.jregistr.graphqllang.psi.impl"

    elementTypeHolderClass="com.jregistr.graphqllang.psi.GraphQlTypes"
    elementTypeClass="com.jregistr.graphqllang.langdef.GraphQlLangElementType"
    tokenTypeClass="com.jregistr.graphqllang.langdef.GraphQlLangTokenType"

    tokens = [
        NOT_YET_IMPL='NOT_YET_IMPLEMENTED'
        TYPE='type'
        INPUT='input'
        ENUM='enum'
        SCALAR='scalar'
        SCHEMA='schema'
        UNION='union'
        INTERFACE='interface'
        IMPLEMENTS='implements'
        QUERY='query'
        FRAGMENT='fragment'

        LEFT_PAREN='('
        RIGHT_PAREN=')'

        LEFT_CURLY='{'
        RIGHT_CURLY='}'

        LEFT_BRACKET='['
        RIGHT_BRACKET=']'

        COLON=':'
        COMMA=','
        EQUALS='='
        PIPE='|'
        REQUIRED='!'
        DIRECTIVE_IDENTIFIER='regexp:@([_A-Za-z][_0-9A-Za-z]*)?'

        identifier="regexp:[_A-Za-z][_0-9A-Za-z]*"
        NUMBER_LITERAL='regexp:-?[0-9]+(\.[0-9+])*'
        STRING_LITERAL='regexp:".*"'
        BOOLEAN_LITERAL='regexp:(true|false)'

        WHITE_SPACE = 'regexp:\s+'
        SINGLE_LINE_COMMENT="regexp:#.*"
    ]
}

// addtl -> additional
// decl -> declaration
// def -> definition
// impl -> implemented(ation)
// sel -> selection

GraphQlDocument ::= Definition*

Definition ::=

ObjectTypeDef
|
InterfaceTypeDef
|
EnumTypeDef
|
UnionTypeDef
|
ScalarTypeDef
|
RootSchemaTypeDef
|
InputObjectTypeDef
|
FragmentDef
|
QueryDef



NamedTypeDef ::= identifier
NameOfSomeType ::= identifier
NameOfSomeField ::= identifier

LITERAL ::= BOOLEAN_LITERAL | NUMBER_LITERAL | STRING_LITERAL

FieldValueDecl ::= LITERAL | ObjectValueDecl

ObjectValueDecl ::= LEFT_CURLY ObjectValueFieldDef ObjectValueAddtlFieldDef* RIGHT_CURLY
ObjectValueFieldDef ::= NameOfSomeField COLON FieldValueDecl
ObjectValueAddtlFieldDef ::= COMMA ObjectValueFieldDef

TypeDecl ::= ListTypeDecl | BasicTypeDecl
BasicTypeDecl ::= NameOfSomeType REQUIRED?
ListTypeDecl ::= LEFT_BRACKET NameOfSomeType REQUIRED? RIGHT_BRACKET

//Distinction to Note and remember
//Argument definition is defining the arguments a field takes. I.E. foo(a: A, b: B): Bar
//Argument declaration stating the named arguments being passed. I.E. foo(a: "Cool", b: "cooler") {...}
ArgumentsDeclSet ::= LEFT_PAREN ArgumentDecl ArgumentAddtlDecl* RIGHT_PAREN
ArgumentDecl ::= NameOfSomeField COLON FieldValueDecl
ArgumentAddtlDecl ::= COMMA ArgumentDecl

ArgumentsDefSet ::= LEFT_PAREN ArgumentDef ArgumentAddtlDef* RIGHT_PAREN
ArgumentDef ::= identifier COLON TypeDecl
ArgumentAddtlDef ::= COMMA ArgumentDef

MemberFieldsSetDef ::= LEFT_CURLY MemberFieldDef+ RIGHT_CURLY
MemberFieldDef ::= identifier ArgumentsDefSet? COLON TypeDecl DirectivesSetDecl?

SimpleMemberFieldsSetDef ::= LEFT_CURLY SimpleMemberFieldDef+ RIGHT_CURLY
SimpleMemberFieldDef ::= identifier COLON TypeDecl

DirectivesSetDecl ::= DirectiveDecl*
DirectiveDecl ::= DIRECTIVE_IDENTIFIER ArgumentsDeclSet?

ObjectTypeDef ::= TYPE NamedTypeDef ObjectTypeImplInterfacesDef? DirectivesSetDecl? MemberFieldsSetDef
ObjectTypeImplInterfacesDef ::= IMPLEMENTS NameOfSomeType ObjectTypeInterfaceAddtlMember*
ObjectTypeInterfaceAddtlMember ::= COMMA NameOfSomeType

InterfaceTypeDef ::= INTERFACE NamedTypeDef MemberFieldsSetDef

EnumTypeDef ::= ENUM NamedTypeDef EnumValuesSetDef
EnumValuesSetDef ::= LEFT_CURLY EnumValueDef EnumAddtlValueDef* RIGHT_CURLY
EnumValueDef ::= identifier
EnumAddtlValueDef ::= COMMA? identifier

UnionTypeDef ::= UNION NamedTypeDef EQUALS UnionMemberDecl UnionAddtlMemberDecl*
UnionMemberDecl ::= NameOfSomeType
UnionAddtlMemberDecl ::= PIPE UnionMemberDecl

ScalarTypeDef ::= SCALAR NamedTypeDef

RootSchemaTypeDef ::= SCHEMA SimpleMemberFieldsSetDef

InputObjectTypeDef ::= INPUT NamedTypeDef SimpleMemberFieldsSetDef


// graphql query specific definitions
FragmentDef ::= NOT_YET_IMPL

QueryDef ::= QueryOperationDecl? QueryFieldExpansion
QueryOperationDecl ::= QUERY identifier DirectivesSetDecl?
QueryFieldExpansion ::= LEFT_CURLY FieldExpansionStatements+ RIGHT_CURLY

FieldExpansionStatements ::= QueryFieldsSelSet | InlineFragmentDecl

QueryFieldsSelSet::= QueryFieldSel QueryFieldAddtlSel*

QueryFieldSel ::= QueryFieldAlias? NameOfSomeField DirectivesSetDecl? QueryFieldExpansion?
QueryFieldAlias ::= identifier COLON
QueryFieldAddtlSel ::= COMMA? QueryFieldSel

InlineFragmentDecl ::= '...' FragmentTypeCondition DirectivesSetDecl? QueryFieldExpansion
FragmentTypeCondition ::= 'on' NameOfSomeType