{
    parserClass="com.jregistr.graphqllang.parser.GraphQlParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="GraphQl"
    psiImplClassSuffix="Impl"
    psiPackage="com.jregistr.graphqllang.psi"
    psiImplPackage="com.jregistr.graphqllang.psi.impl"

    elementTypeHolderClass="com.jregistr.graphqllang.psi.GraphQlTokenTypes"
    elementTypeClass="com.jregistr.graphqllang.langdef.GraphQlLangElementType"
    tokenTypeClass="com.jregistr.graphqllang.langdef.GraphQlLangTokenType"

    tokens = [
        NOT_IMPL='NOT_YET_IMPL'
        TYPE='type'
        INPUT='input'
        ENUM='enum'
        SCALAR='scalar'
        SCHEMA='schema'
        UNION='union'
        INTERFACE='interface'
        IMPLEMENTS='implements'
        QUERY='query'
        FRAGMENT='fragment'
        DIRECTIVE='directive'
        QUERY='query'
        MUTATION='mutation'
        SUBSCRIPTION='subscription'
        EXTEND='extend'

        LEFT_PAREN='('
        RIGHT_PAREN=')'

        LEFT_CURLY='{'
        RIGHT_CURLY='}'

        LEFT_BRACKET='['
        RIGHT_BRACKET=']'

        COLON=':'
        COMMA=','
        EQUALS='='
        PIPE='|'
        REQUIRED='!'
        AMPERSAND='&'

        DIRECTIVE_IDENTIFIER='regexp:@(_?[A-Za-z][_0-9A-Za-z]*)'
        VARIABLE_IDENTIFIER='regexp:\$([_A-Za-z][_0-9A-Za-z]*)'
        FRAGMENT_DOTS='...'
        ON='on'

        IDENTIFIER="regexp:[_A-Za-z][_0-9A-Za-z]*"
        STRING_LITERAL='regexp:".*"'
        NUMBER_LITERAL='regexp:-?[0-9]+(\.[0-9]+)?'

        WHITE_SPACE = 'regexp:\s+'
        SINGLE_LINE_COMMENT="regexp:#.*"
    ]
}

// addtl -> additional
// decl -> declaration
// def -> definition
// impl -> implemented(ation)
// sel -> selection
// cond -> condition
// loc -> location

GraphQlDocument ::= Definition*

Definition ::=
SDLDefinition
|
ExecutableDef

SDLDefinition ::=
TypeSystemDef
|
TypeSystemExtension

//<><><><><><><><><><><><><><><><><><><>[Common/Misc]<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

TypeName ::= IDENTIFIER
FieldName ::= IDENTIFIER
EnumValue ::= IDENTIFIER

Literal ::= NUMBER_LITERAL | STRING_LITERAL | BOOLEAN_LITERAL
BOOLEAN_LITERAL ::= 'true' | 'false'

// I.E. 10 or "foobar" or [1 2 3 4] or {a: 10 b: false}.
// Note:!!, CANNOT refer to variables via $foo
FieldValueDecl ::= Literal | ObjectValueDecl | ArrayValueDecl | EnumValue

// I.E. { a: "foobar" b: true }
ObjectValueDecl ::= LEFT_CURLY ObjectValueFieldDecl ObjectValueAddtlFieldDecl* RIGHT_CURLY
ObjectValueFieldDecl ::= FieldName COLON FieldValueDecl
ObjectValueAddtlFieldDecl ::= COMMA? ObjectValueFieldDecl

ArrayValueDecl ::= LEFT_BRACKET ArrayMemberDecl ArrayMemberAddtlDecl* RIGHT_BRACKET
ArrayMemberDecl ::= FieldValueDecl
ArrayMemberAddtlDecl ::= COMMA? ArrayMemberDecl

// I.E. : Float or : Foobar
CompositeFieldTypeDecl ::= COLON FieldTypeDecl

// I.E. Float! or [[Float!]!]!
FieldTypeDecl ::= BasicTypeDecl | ListTypeDecl
BasicTypeDecl ::= TypeName REQUIRED?
ListTypeDecl ::= LEFT_BRACKET FieldTypeDecl RIGHT_BRACKET REQUIRED?

// I.E. @foo @bar(a: 10) @baz
DirectivesDeclSet ::= DirectiveDecl+
DirectiveDecl ::= DIRECTIVE_IDENTIFIER DirectiveArgumentsSetDecl?
// I.E. (a: 10 b: false c: "true")
DirectiveArgumentsSetDecl ::= LEFT_PAREN DirectiveArgumentDecl AddtlDirectiveArgumentDecl* RIGHT_PAREN
DirectiveArgumentDecl ::= FieldName COLON FieldValueDecl
AddtlDirectiveArgumentDecl ::= COMMA? DirectiveArgumentDecl

//<><><><><><><><><><><><><><><><><><><>[Schema Definition Language]<><><><><><><><><><><><><><><><><><><><><><><><><><>
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

TypeSystemDef ::=
RootSchemaTypeDef
|
TypeDefinition
|
DirectiveTypeDef


TypeDefinition ::=
ScalarTypeDef
|
ObjectTypeDef
|
InterfaceTypeDef
|
UnionTypeDef
|
EnumTypeDef
|
InputObjectTypeDef


TypeSystemExtension ::=
ExtendRootSchema
|
TypeExtension

TypeExtension ::=
ExtendScalar
|
ExtendObjectType
|
ExtendInterface
|
ExtendUnion
|
ExtendEnum
|
ExtendInputObject

NamedTypeDef ::= IDENTIFIER

// I.E. (a: BB = 10, c:DD)
InputsDef ::= LEFT_PAREN InputValueSetDef RIGHT_PAREN

// I.E. foo: Bar = false baz: Foobar
InputValueSetDef ::= InputDef AddtlInputDef*
InputDef ::= FieldName CompositeFieldTypeDecl InputDefaultValueDef? DirectivesDeclSet?
AddtlInputDef ::= COMMA? InputDef
InputDefaultValueDef ::= EQUALS FieldValueDecl

// I.E. {a: Int b: Float}
FieldsDefSet ::= LEFT_CURLY FieldDef AddtlFieldDef* RIGHT_CURLY
FieldDef ::= FieldName InputsDef? CompositeFieldTypeDecl DirectivesDeclSet?
AddtlFieldDef ::= COMMA? FieldDef


// I.E. schema {query: Query}
RootSchemaTypeDef ::= SCHEMA DirectivesDeclSet? RootSchemaOperationsSetDef
RootSchemaOperationsSetDef ::= LEFT_CURLY RootSchemaOperationTypeDef RootSchemaAddtlOperationTypeDef* RIGHT_CURLY
RootSchemaOperationTypeDef ::= FieldName COLON TypeName
RootSchemaAddtlOperationTypeDef ::= COMMA? RootSchemaOperationTypeDef

// ---------- TypeDefinition -------------------------------------------------------------------------------------------

// I.E. type Dog implements Animal & Pet { bark(loudness: String = "Over 9000!" @foo @bar(a: 11)): Bark }
ObjectTypeDef ::= TYPE NamedTypeDef ImplInterfacesDeclSet? DirectivesDeclSet? FieldsDefSet?
// I.E. implements Foo & Bar & Baz
ImplInterfacesDeclSet ::= IMPLEMENTS TypeName AddtlInterfacesSet?
AddtlInterfacesSet ::= AdditionalInterface+
AdditionalInterface ::= AMPERSAND? TypeName

// I.E. interface Animal @foo {walk(distance: Int): Float}
InterfaceTypeDef ::= INTERFACE NamedTypeDef DirectivesDeclSet? FieldsDefSet?

// I.E. enum Direction { NORTH, SOUTH, EAST @value("west"), WEST @value("west") }
EnumTypeDef ::= ENUM NamedTypeDef DirectivesDeclSet? EnumValuesDefSet?
EnumValuesDefSet ::= LEFT_CURLY EnumValueDef EnumAddtlValueDef* RIGHT_CURLY
EnumValueDef ::= EnumValue DirectivesDeclSet?
EnumAddtlValueDef ::= COMMA? EnumValueDef

// I.E. union SupersonicVehicles = Jets | Rockets
UnionTypeDef ::= UNION NamedTypeDef DirectivesDeclSet? UnionMembersSetDef?
UnionMembersSetDef ::= EQUALS UnionMemberDef UnionAddtlMemberDef*
UnionMemberDef ::= TypeName
UnionAddtlMemberDef ::= PIPE? UnionMemberDef

// I.E. scalar DateTime @foo
ScalarTypeDef ::= SCALAR NamedTypeDef DirectivesDeclSet?

// I.E. input Point2D { x: Float @foo, y: Float }
InputObjectTypeDef ::= INPUT NamedTypeDef DirectivesDeclSet? InputObjectFieldsSetDef?
InputObjectFieldsSetDef ::= LEFT_CURLY InputValueSetDef RIGHT_CURLY

// I.E. directive @example on FIELD_DEFINITION | ARGUMENT_DEFINITION
DirectiveTypeDef ::= DIRECTIVE DIRECTIVE_IDENTIFIER InputsDef? DirectiveLocationsConditionDef
DirectiveLocationsConditionDef ::= ON DirectiveLocation DirectiveAddtlLocation*
DirectiveLocation ::= IDENTIFIER
DirectiveAddtlLocation ::= PIPE? DirectiveLocation

// ---------- Schema extensions ----------------------------------------------------------------------------------------
ExtendAddDirectives ::= DirectivesDeclSet

// I.E. extend schema @foo or extend schema @foo {mutation: SuperMutants}
ExtendRootSchema ::= EXTEND SCHEMA ExtendRootSchemaAdditions
ExtendRootSchemaAdditions ::= ExtendAddDirectives | ExtendRootSchemaAddOperations
ExtendRootSchemaAddOperations ::= DirectivesDeclSet? RootSchemaOperationsSetDef

// I.E. extend scalar Foo @bar
ExtendScalar ::= EXTEND SCALAR TypeName ExtendAddDirectives

// I.E. extend type Foo implements Bar or extend type Foo @bar or extend type Foo {a: B}
ExtendObjectType ::= EXTEND TYPE TypeName ExtendObjectTypeAdditions
ExtendObjectTypeAdditions ::=
ExtendObjectTypeAddFields
|
ExtendObjectTypeAddDirectives
|
ExtendObjectTypeAddInterfaces

ExtendObjectTypeAddInterfaces ::= ImplInterfacesDeclSet
ExtendObjectTypeAddDirectives ::= ImplInterfacesDeclSet? ExtendAddDirectives
ExtendObjectTypeAddFields ::= ImplInterfacesDeclSet? DirectivesDeclSet? FieldsDefSet

// I.E. extend interface Foo @bar or extend interface Foo {a: B}
ExtendInterface ::= EXTEND INTERFACE TypeName ExtendInterfaceAdditions
ExtendInterfaceAdditions ::= ExtendInterfaceAddFields | ExtendAddDirectives
ExtendInterfaceAddFields ::= DirectivesDeclSet? FieldsDefSet

// extend union Foo @baz or extend union Foo = Baz
ExtendUnion ::= EXTEND UNION TypeName ExtendUnionAdditions
ExtendUnionAdditions ::= ExtendUnionAddMembers | ExtendAddDirectives
ExtendUnionAddMembers ::= DirectivesDeclSet? UnionMembersSetDef

ExtendEnum ::= EXTEND ENUM TypeName ExtendEnumAdditions
ExtendEnumAdditions ::= ExtendEnumAddValues | ExtendAddDirectives
ExtendEnumAddValues ::= DirectivesDeclSet? EnumValuesDefSet

ExtendInputObject ::= EXTEND INPUT TypeName ExtendInputObjectAdditions
ExtendInputObjectAdditions ::= ExtendInputObjectAddMembers | ExtendAddDirectives
ExtendInputObjectAddMembers ::= DirectivesDeclSet? InputObjectFieldsSetDef
//<><><><><><><><><><><><><><><><><><><><><><>[Executable definitions]<><><><><><><><><><><><><><><><><><><><><><><><><>
//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

ExecutableDef ::=
OperationDef
|
FragmentDef

OperationName ::= IDENTIFIER
VariableName ::= VARIABLE_IDENTIFIER
VariableReference ::= VARIABLE_IDENTIFIER
Null_Value ::= 'null'

OperationFieldValueDecl ::= COLON CompositeFieldValueDecl
CompositeFieldValueDecl ::= Null_Value | Literal | CompositeObjectValueDecl | CompositeArrayValueDecl | EnumValue | VariableReference

// I.E. { a: "foobar" b: $someVariable }
CompositeObjectValueDecl ::= LEFT_CURLY CompositeObjectValueFieldDecl CompositeObjectValueAddtlFieldDecl* RIGHT_CURLY
CompositeObjectValueFieldDecl ::= FieldName COLON CompositeFieldValueDecl
CompositeObjectValueAddtlFieldDecl ::= COMMA? CompositeObjectValueFieldDecl

// I.E. [1 2 $var]
CompositeArrayValueDecl ::= LEFT_BRACKET CompositeArrayMemberDecl CompositeArrayMemberAddtlDecl* RIGHT_BRACKET
CompositeArrayMemberDecl ::= CompositeFieldValueDecl
CompositeArrayMemberAddtlDecl ::= COMMA? CompositeArrayMemberDecl

// I.E. (a: 10 b: $varName)
ArgumentDeclSet ::= LEFT_PAREN ArgumentDeclDecl AddtlArgumentDeclDecl* RIGHT_PAREN
ArgumentDeclDecl ::= FieldName OperationFieldValueDecl
AddtlArgumentDeclDecl ::= COMMA? ArgumentDeclDecl

// I.E. query example($var1: Int = 10 $var2: String) {f1, alias(foo: $var1): f2}
OperationDef ::= CompositeOperationDef SelectionSetDecl
CompositeOperationDef ::= OperationTypeDecl OperationName? VariablesSetDef? DirectivesDeclSet?
OperationTypeDecl ::= QUERY | MUTATION | SUBSCRIPTION

// I.E. ($var1: Int = 10 $var2: String)
VariablesSetDef ::= LEFT_PAREN VariableDef AddtlVariablesDef* RIGHT_PAREN
VariableDef ::= VariableName CompositeFieldTypeDecl InputDefaultValueDef? DirectivesDeclSet?
AddtlVariablesDef ::= COMMA? VariableDef

// I.E. { a b c ... on Foo {...}, ... onBaz}
SelectionSetDecl ::= LEFT_CURLY Selections RIGHT_CURLY
Selections ::= Selection AddtlSelectionDecl*

Selection ::=
FieldSelection
|
FragmentSpread
|
InlineFragment
AddtlSelectionDecl ::= COMMA? Selection

FieldSelection ::= FieldNameDecl ArgumentDeclSet? SelectionDirectivesDeclSet? SelectionSetDecl?
FieldNameDecl ::= AliasedFieldName | FieldName
AliasedFieldName ::= IDENTIFIER COLON FieldName



/*
DirectivesDeclSet ::= DirectiveDecl+
DirectiveDecl ::= DIRECTIVE_IDENTIFIER DirectiveArgumentsSetDecl?
// I.E. (a: 10 b: false c: "true")
DirectiveArgumentsSetDecl ::= LEFT_PAREN DirectiveArgumentDecl AddtlDirectiveArgumentDecl* RIGHT_PAREN
DirectiveArgumentDecl ::= FieldName COLON FieldValueDecl
AddtlDirectiveArgumentDecl ::= COMMA? DirectiveArgumentDecl
*/

/*
// I.E. (a: 10 b: false c: "true")
SchemaArgumentsSetDecl ::= LEFT_PAREN SchemaArgumentDecl AddtlSchemaArgumentDecl* RIGHT_PAREN
SchemaArgumentDecl ::= FieldName COLON FieldValueDecl
AddtlSchemaArgumentDecl ::= COMMA? SchemaArgumentDecl

// I.E. @foo @bar(a: 10) @baz
SchemaDirectivesSetDecl ::= SchemaDirectiveDecl+
SchemaDirectiveDecl ::= DIRECTIVE_IDENTIFIER SchemaArgumentsSetDecl?
*/








//
/*
OperationDef ::= MaybeFullOperationDef? LEFT_CURLY SelectionSetDecl RIGHT_CURLY
MaybeFullOperationDef ::= OperationTypeDecl IDENTIFIER? OperationVariablesSetDef? OperationDirectivesDeclSet?
OperationTypeDecl ::= QUERY | MUTATION | SUBSCRIPTION

OperationVariablesSetDef ::= LEFT_PAREN OperationVariableDef OperationAddtlVariableDef* RIGHT_PAREN
OperationVariableDef ::= VARIABLE_IDENTIFIER COLON TypeDecl DefaultValueDef?
OperationAddtlVariableDef ::= COMMA? OperationVariableDef
*/



/*
NamedTypeDef ::= IDENTIFIER
NameOfSomeType ::= IDENTIFIER
NameOfSomeField ::= IDENTIFIER
DirectiveLocation ::= IDENTIFIER

BOOLEAN_LITERAL ::= 'true' | 'false'
Literal ::= NUMBER_LITERAL | STRING_LITERAL | BOOLEAN_LITERAL
VariableReference ::= VARIABLE_IDENTIFIER
StaticValue ::= IDENTIFIER

SimpleFieldValueDecl ::= Literal | SimpleObjectValueDecl | SimpleArrayValuesDecl | StaticValue

SimpleObjectValueDecl ::= LEFT_CURLY SimpleObjectValueFieldDecl SimpleObjectValueAddtlFieldDecl* RIGHT_CURLY
SimpleObjectValueFieldDecl ::= NameOfSomeField COLON SimpleFieldValueDecl
SimpleObjectValueAddtlFieldDecl ::= COMMA? SimpleObjectValueFieldDecl

SimpleArrayValuesDecl ::= LEFT_BRACKET SimpleArrayInnerValDecl SimpleArrayInnerValAddtlDecl* RIGHT_BRACKET
SimpleArrayInnerValDecl ::= SimpleFieldValueDecl
SimpleArrayInnerValAddtlDecl ::= COMMA? SimpleArrayInnerValDecl

///------------
CompositeFieldValueDecl ::= Literal | CompositeObjectValueDecl | CompositeArrayValuesDecl | VariableReference | StaticValue

CompositeArrayValuesDecl ::= LEFT_BRACKET CompositeArrayInnerValDecl CompositeArrayInnerValAddtlDecl* RIGHT_BRACKET
CompositeArrayInnerValDecl ::= CompositeFieldValueDecl
CompositeArrayInnerValAddtlDecl ::= COMMA? CompositeArrayInnerValDecl

CompositeObjectValueDecl ::= LEFT_CURLY CompositeObjectValueFieldDecl CompositeObjectValueFieldAddtlDecl* RIGHT_CURLY
CompositeObjectValueFieldDecl ::= NameOfSomeField COLON CompositeFieldValueDecl
CompositeObjectValueFieldAddtlDecl ::= COMMA? CompositeObjectValueFieldDecl

TypeDecl ::= BasicTypeDecl | ListTypeDecl
BasicTypeDecl ::= NameOfSomeType REQUIRED?
ListTypeDecl ::= LEFT_BRACKET BasicTypeDecl RIGHT_BRACKET REQUIRED?

//Distinction to Note and remember
//Argument definition is defining the arguments a field takes. I.E. foo(a: A, b: B): Bar
//Argument declaration stating the named arguments being passed. I.E. foo(a: "Cool", b: "cooler") {...}
SchemaArgumentsDeclSet ::= LEFT_PAREN SchemaArgumentDecl SchemaArgumentAddtlDecl* RIGHT_PAREN
SchemaArgumentDecl ::= NameOfSomeField COLON SimpleFieldValueDecl
SchemaArgumentAddtlDecl ::= COMMA? SchemaArgumentDecl

OperationArgumentDeclSet ::= LEFT_PAREN OperationArgumentDecl OperationArgumentAddtlDecl* RIGHT_PAREN
OperationArgumentDecl ::= NameOfSomeField COLON CompositeFieldValueDecl
OperationArgumentAddtlDecl ::= COMMA? OperationArgumentDecl


ArgumentsDefSet ::= LEFT_PAREN ArgumentDef ArgumentAddtlDef* RIGHT_PAREN
ArgumentDef ::= NamedTypeDef COLON TypeDecl DefaultValueDef? SchemaDirectivesDeclSet?
DefaultValueDef ::= EQUALS SimpleFieldValueDecl
ArgumentAddtlDef ::= COMMA ArgumentDef

FieldDefName ::= IDENTIFIER

MemberFieldsSetDef ::= LEFT_CURLY MemberFieldDef MemberFieldAddtlDef* RIGHT_CURLY
MemberFieldDef ::= FieldDefName ArgumentsDefSet? COLON TypeDecl SchemaDirectivesDeclSet?
MemberFieldAddtlDef ::= COMMA? MemberFieldDef

SimpleMemberFieldsSetDef ::= LEFT_CURLY SimpleMemberFieldDef SimpleAddtlMemberFieldDef* RIGHT_CURLY
SimpleMemberFieldDef ::= FieldDefName COLON TypeDecl
SimpleAddtlMemberFieldDef ::= COMMA? SimpleMemberFieldDef

// Directive declaration is using directive such as on a field or object. I.E. field {a@foo}
// Directive definition is defining some directive. i.e. directive @foo on Field
SchemaDirectivesDeclSet ::= SchemaDirectiveDecl*
SchemaDirectiveDecl ::= DIRECTIVE_IDENTIFIER SchemaArgumentsDeclSet?

OperationDirectivesDeclSet ::= OperationDirectiveDecl*
OperationDirectiveDecl ::= DIRECTIVE_IDENTIFIER OperationArgumentDeclSet?



TypeDef ::=
RootSchemaTypeDef
|
ObjectTypeDef
|
InterfaceTypeDef
|
EnumTypeDef
|
DirectiveDef
|
UnionTypeDef
|
ScalarTypeDef
|
ExtendScalarDef
|
InputObjectTypeDef
|
ExtendTypeDef

RootSchemaTypeDef ::= SCHEMA SchemaDirectivesDeclSet? RootSchemaOperationTypesDefSet
RootSchemaOperationTypesDefSet ::= LEFT_CURLY RootSchemaOperationTypeDef RootSchemaAddtlOperationTypeDef* RIGHT_CURLY
RootSchemaOperationTypeDef ::= IDENTIFIER COLON NameOfSomeType
RootSchemaAddtlOperationTypeDef ::= COMMA? RootSchemaOperationTypeDef

ObjectTypeDef ::= TYPE NamedTypeDef ObjectTypeImplInterfacesDef? SchemaDirectivesDeclSet? MemberFieldsSetDef
ObjectTypeImplInterfacesDef ::= IMPLEMENTS NameOfSomeType ObjectTypeInterfaceAddtlMember*
ObjectTypeInterfaceAddtlMember ::= COMMA NameOfSomeType

InterfaceTypeDef ::= INTERFACE NamedTypeDef MemberFieldsSetDef

EnumTypeDef ::= ENUM NamedTypeDef EnumValuesSetDef
EnumValuesSetDef ::= LEFT_CURLY EnumValueDef EnumAddtlValueDef* RIGHT_CURLY
EnumValueDef ::= IDENTIFIER
EnumAddtlValueDef ::= COMMA? IDENTIFIER

DirectiveDef ::= DIRECTIVE DIRECTIVE_IDENTIFIER ArgumentsDefSet? DirectiveDefLocCondSet
DirectiveDefLocCondSet ::= 'on' DirectiveLocation DirectiveDefLocAddtlCond*
DirectiveDefLocAddtlCond ::= PIPE DirectiveLocation

UnionTypeDef ::= UNION NamedTypeDef EQUALS UnionMemberDecl UnionAddtlMemberDecl*
UnionMemberDecl ::= NameOfSomeType
UnionAddtlMemberDecl ::= PIPE UnionMemberDecl

ScalarTypeDef ::= SCALAR NamedTypeDef SchemaDirectivesDeclSet?

ExtendScalarDef ::= EXTEND SCALAR NamedTypeDef SchemaDirectivesDeclSet?

InputObjectTypeDef ::= INPUT NamedTypeDef SimpleMemberFieldsSetDef

ExtendTypeDef ::= EXTEND TYPE NameOfSomeType MemberFieldsSetDef


ExecutableDef ::=
OperationDef
|
FragmentDef

OperationDef ::= MaybeFullOperationDef? LEFT_CURLY SelectionSetDecl RIGHT_CURLY
MaybeFullOperationDef ::= OperationTypeDecl IDENTIFIER? OperationVariablesSetDef? OperationDirectivesDeclSet?
OperationTypeDecl ::= QUERY | MUTATION | SUBSCRIPTION

OperationVariablesSetDef ::= LEFT_PAREN OperationVariableDef OperationAddtlVariableDef* RIGHT_PAREN
OperationVariableDef ::= VARIABLE_IDENTIFIER COLON TypeDecl DefaultValueDef?
OperationAddtlVariableDef ::= COMMA? OperationVariableDef

SelectionSetDecl ::= Selection AddtlSelection*

Selection ::=
FieldSelection
|
FragmentSpread
|
InlineFragment

AddtlSelection ::= COMMA? Selection

FieldSelection ::= FieldAlias? NameOfSomeField OperationArgumentDeclSet? OperationDirectivesDeclSet? FieldExpansionDecl?
FieldAlias ::= IDENTIFIER COLON
FieldExpansionDecl ::= LEFT_CURLY SelectionSetDecl RIGHT_CURLY

FragmentSpread ::= FRAGMENT_DOTS IDENTIFIER OperationDirectivesDeclSet?

InlineFragment ::= FRAGMENT_DOTS FragmentTypeCondition OperationDirectivesDeclSet? FieldExpansionDecl

FragmentTypeCondition ::= FRAGMENT_ON NameOfSomeType

FragmentDef ::= FRAGMENT IDENTIFIER FragmentTypeCondition OperationDirectivesDeclSet? LEFT_CURLY SelectionSetDecl RIGHT_CURLY
 */


/*
MaybeAddtlInterfaces?

MaybeAddtlInterfaces ::= AddtlInterfacesSetDecl | LegacyAddtlInterfacesSetDecl
AddtlInterfacesSetDecl ::= AddtlInterfaceDecl+
AddtlInterfaceDecl ::= AMPERSAND TypeName
LegacyAddtlInterfacesSetDecl ::= AddtlLegacyInterfaceDecl+
AddtlLegacyInterfaceDecl ::= COMMA TypeName
*/